// src/workflow/workflow-manager-enhanced.ts - Agent-Aware Workflow Management

import { Workspace } from '../workspace/workspace';
import { AgentRegistry, AgentInvoker, type AgentInvocation, type AgentResult } from '../agents/agent-wrapper';
import type { GeminiClient } from '../gemini';
import type { VectorizeIndex } from '@cloudflare/workers-types';
import type { WorkflowTemplate, TodoDocument, TodoStep } from '../types';

// =============================================================
// Enhanced Workflow Types
// =============================================================

export interface EnhancedWorkflowStep {
  number: number;
  title: string;
  agentId: string;                      // Which agent to use
  objective: string;
  dependencies: StepDependency[];        // Previous step outputs
  agentConfig: AgentStepConfig;
  outputs: string[];
  checkpoint: boolean;
  estimatedTurns: number;
}

export interface StepDependency {
  stepNumber: number;
  outputPath: string;
}

export interface AgentStepConfig {
  objective: string;
  requirements: string[];
  outputFormat: string;
  constraints?: string[];
  userContext?: Record<string, string>;
}

export interface EnhancedTodoStep extends TodoStep {
  agentId?: string;
  agentConfig?: AgentStepConfig;
  dependencies?: StepDependency[];
}

// =============================================================
// Enhanced Workflow Manager
// =============================================================

export class EnhancedWorkflowManager {
  private vectorize: VectorizeIndex | null;
  private gemini: GeminiClient;
  private sessionId: string;
  private agentRegistry: AgentRegistry;
  private agentInvoker: AgentInvoker;
  private templatesBasePath = 'workflows/templates';
  
  private templateCache = new Map<string, WorkflowTemplate>();

  constructor(
    vectorize: VectorizeIndex | null,
    gemini: GeminiClient,
    sessionId: string
  ) {
    this.vectorize = vectorize;
    this.gemini = gemini;
    this.sessionId = sessionId;
    
    // Initialize agent system
    this.agentRegistry = new AgentRegistry(Workspace, gemini, vectorize);
    this.agentInvoker = new AgentInvoker(gemini, this.agentRegistry);
  }

  // -----------------------------------------------------------
  // Enhanced Step Execution with Agents
  // -----------------------------------------------------------

  async executeStepWithAgent(
    projectPath: string,
    stepNumber: number,
    callbacks?: {
      onThought?: (thought: string) => void;
      onAction?: (action: string) => void;
      onObservation?: (obs: string) => void;
      onChunk?: (chunk: string) => void;
      onStatus?: (msg: string) => void;
    }
  ): Promise<{
    success: boolean;
    outputs: any;
    metadata: {
      agentId: string;
      tokensUsed: number;
      latency: number;
    };
  }> {
    // Load todo document
    const todo = await this.loadTodoDocument(projectPath);
    if (!todo) {
      throw new Error('Todo document not found');
    }

    const step = todo.steps.find(s => s.number === stepNumber) as EnhancedTodoStep;
    if (!step) {
      throw new Error(`Step ${stepNumber} not found`);
    }

    if (!step.agentId) {
      throw new Error(`Step ${stepNumber} has no agent assigned`);
    }

    callbacks?.onStatus?.(`Loading agent: ${step.agentId}`);

    // Load dependencies from previous steps
    const inputSources: Record<string, any> = {};
    if (step.dependencies) {
      for (const dep of step.dependencies) {
        try {
          const content = await Workspace.readFileText(`${projectPath}/${dep.outputPath}`);
          inputSources[`step${dep.stepNumber}`] = this.parseContent(content);
        } catch (e) {
          console.warn(`Failed to load dependency: ${dep.outputPath}`);
        }
      }
    }

    callbacks?.onStatus?.(`Invoking agent: ${step.agentId}`);

    // Build agent invocation
    const invocation: AgentInvocation = {
      agentId: step.agentId,
      objective: step.agentConfig?.objective || step.description,
      requirements: step.agentConfig?.requirements || [],
      inputSources,
      userContext: step.agentConfig?.userContext,
      outputFormat: step.agentConfig?.outputFormat || 'markdown',
      constraints: step.agentConfig?.constraints,
    };

    // Invoke agent
    const result = await this.agentInvoker.invoke(invocation);

    if (!result.success) {
      throw new Error(`Agent execution failed: ${result.error}`);
    }

    // Save outputs
    await this.saveStepOutputs(projectPath, step, result.output);

    return {
      success: true,
      outputs: result.output,
      metadata: result.metadata,
    };
  }

  private parseContent(content: string): any {
    // Try JSON first
    try {
      return JSON.parse(content);
    } catch {
      // Return as text
      return content;
    }
  }

  private async saveStepOutputs(
    projectPath: string,
    step: EnhancedTodoStep,
    output: any
  ): Promise<void> {
    if (!step.outputs || step.outputs.length === 0) {
      // Default output
      const defaultPath = `data/step${step.number}_output.json`;
      await Workspace.writeFile(
        `${projectPath}/${defaultPath}`,
        typeof output === 'string' ? output : JSON.stringify(output, null, 2)
      );
      return;
    }

    // Save to specified outputs
    for (const outputPath of step.outputs) {
      const fullPath = `${projectPath}/${outputPath}`;
      
      if (outputPath.endsWith('.json')) {
        await Workspace.writeFile(
          fullPath,
          typeof output === 'string' ? output : JSON.stringify(output, null, 2)
        );
      } else if (outputPath.endsWith('.md')) {
        await Workspace.writeFile(
          fullPath,
          typeof output === 'string' ? output : JSON.stringify(output)
        );
      } else {
        await Workspace.writeFile(fullPath, String(output));
      }
    }
  }

  // -----------------------------------------------------------
  // Enhanced Project Creation
  // -----------------------------------------------------------

  async createProjectFromTemplate(
    workflowId: string,
    objective: string,
    userContext?: Record<string, string>
  ): Promise<{ projectId: string; projectPath: string }> {
    if (!Workspace.isInitialized()) {
      throw new Error('Workspace not initialized');
    }

    const template = await this.getTemplate(workflowId);
    if (!template) {
      throw new Error(`Template not found: ${workflowId}`);
    }

    const projectId = `project_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const projectPath = `${this.sessionId}/${projectId}`;

    try {
      console.log(`[WorkflowManager] Creating project: ${projectId} from ${workflowId}`);

      // Create project structure
      await Workspace.createDirectoryStructure(projectPath, [
        'data',
        'results',
        'artifacts',
      ]);

      // Assign agents to steps and create todo
      const todoDoc = await this.createEnhancedTodo(
        template,
        objective,
        projectId,
        userContext
      );
      await this.saveTodoDocument(projectPath, todoDoc);

      // Create README
      await Workspace.writeFile(
        `${projectPath}/README.md`,
        this.generateReadme(projectId, objective, template)
      );

      console.log(`[WorkflowManager] âœ… Project created: ${projectId}`);
      return { projectId, projectPath };
    } catch (e) {
      const error = e instanceof Error ? e.message : String(e);
      throw new Error(`Project creation failed: ${error}`);
    }
  }

  private async createEnhancedTodo(
    template: WorkflowTemplate,
    objective: string,
    projectId: string,
    userContext?: Record<string, string>
  ): Promise<TodoDocument> {
    const enhancedSteps: EnhancedTodoStep[] = [];

    for (const templateStep of template.steps) {
      // Find appropriate agent for this step
      const agent = await this.findBestAgentForStep(templateStep);

      // Build dependencies
      const dependencies: StepDependency[] = [];
      if (templateStep.number > 1) {
        // By default, depend on previous step
        const prevStep = template.steps[templateStep.number - 2];
        if (prevStep.outputs && prevStep.outputs.length > 0) {
          dependencies.push({
            stepNumber: prevStep.number,
            outputPath: prevStep.outputs[0],
          });
        }
      }

      enhancedSteps.push({
        number: templateStep.number,
        title: templateStep.title,
        description: templateStep.description,
        status: 'pending',
        checkpoint: templateStep.checkpoint,
        outputs: templateStep.outputs,
        agentId: agent?.id || 'generic_agent',
        agentConfig: {
          objective: templateStep.description,
          requirements: this.extractRequirements(templateStep.description),
          outputFormat: this.inferOutputFormat(templateStep.outputs),
          userContext,
        },
        dependencies,
      });
    }

    return {
      objective,
      projectId,
      workflowId: template.id,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      steps: enhancedSteps,
    };
  }

  private async findBestAgentForStep(
    step: import('../types').WorkflowStep
  ): Promise<{ id: string } | null> {
    // Build search query from step
    const query = `${step.title} ${step.description} ${step.tools.join(' ')}`;
    
    const agents = await this.agentRegistry.searchAgents(
      query,
      step.tools.length > 0 ? step.tools : undefined,
      undefined,
      1
    );

    return agents.length > 0 ? { id: agents[0].id } : null;
  }

  private extractRequirements(description: string): string[] {
    // Simple extraction of bullet points or requirements
    const lines = description.split('\n');
    return lines
      .filter(line => line.trim().match(/^[-*â€¢]\s+/))
      .map(line => line.trim().replace(/^[-*â€¢]\s+/, ''));
  }

  private inferOutputFormat(outputs: string[]): string {
    if (outputs.length === 0) return 'markdown';
    
    const firstOutput = outputs[0];
    if (firstOutput.endsWith('.json')) return 'JSON';
    if (firstOutput.endsWith('.md')) return 'markdown';
    if (firstOutput.endsWith('.py')) return 'python code';
    
    return 'markdown';
  }

  // -----------------------------------------------------------
  // Template Management (Same as before)
  // -----------------------------------------------------------

  async searchTemplates(query: string, limit = 3): Promise<WorkflowTemplate[]> {
    if (!this.vectorize) {
      return await this.listAllTemplates();
    }

    try {
      const queryEmbedding = await this.gemini.embedText(query, { normalize: true });

      const results = await this.vectorize.query(queryEmbedding, {
        topK: limit,
        filter: { type: 'workflow_template' },
        returnMetadata: true,
      });

      const templates: WorkflowTemplate[] = [];

      for (const match of results.matches || []) {
        if (match.score >= 0.6) {
          const templateId = match.metadata?.template_id as string;
          if (templateId) {
            const template = await this.getTemplate(templateId);
            if (template) templates.push(template);
          }
        }
      }

      return templates;
    } catch (e) {
      console.error('[WorkflowManager] Search failed:', e);
      return await this.listAllTemplates();
    }
  }

  async listAllTemplates(): Promise<WorkflowTemplate[]> {
    if (!Workspace.isInitialized()) return [];

    try {
      const listing = await Workspace.readdir(this.templatesBasePath);
      const templates: WorkflowTemplate[] = [];

      for (const file of listing.files) {
        if (file.name.endsWith('.md')) {
          const templateId = file.name.replace('.md', '');
          const template = await this.getTemplate(templateId);
          if (template) templates.push(template);
        }
      }

      return templates;
    } catch (e) {
      console.warn('[WorkflowManager] List templates failed:', e);
      return [];
    }
  }

  async getTemplate(templateId: string): Promise<WorkflowTemplate | null> {
    if (this.templateCache.has(templateId)) {
      return this.templateCache.get(templateId)!;
    }

    if (!Workspace.isInitialized()) return null;

    try {
      const path = `${this.templatesBasePath}/${templateId}.md`;
      const content = await Workspace.readFileText(path);
      const template = this.parseTemplateMarkdown(templateId, content);
      
      this.templateCache.set(templateId, template);
      return template;
    } catch (e) {
      console.error(`[WorkflowManager] Failed to load template ${templateId}:`, e);
      return null;
    }
  }

  // -----------------------------------------------------------
  // Todo Document Management
  // -----------------------------------------------------------

  async loadTodoDocument(projectPath: string): Promise<TodoDocument | null> {
    try {
      const content = await Workspace.readFileText(`${projectPath}/todo.md`);
      return this.parseTodoMarkdown(content);
    } catch (e) {
      console.error('[WorkflowManager] Failed to load todo.md:', e);
      return null;
    }
  }

  async saveTodoDocument(projectPath: string, todo: TodoDocument): Promise<void> {
    const markdown = this.generateTodoMarkdown(todo);
    await Workspace.writeFile(`${projectPath}/todo.md`, markdown);
  }

  async updateStepStatus(
    projectPath: string,
    stepNumber: number,
    status: 'pending' | 'in_progress' | 'completed' | 'skipped',
    notes?: string
  ): Promise<void> {
    const todo = await this.loadTodoDocument(projectPath);
    if (!todo) throw new Error('Todo document not found');

    const step = todo.steps.find(s => s.number === stepNumber);
    if (!step) throw new Error(`Step ${stepNumber} not found`);

    step.status = status;
    if (notes) step.notes = notes;

    if (status === 'in_progress' && !step.startedAt) {
      step.startedAt = Date.now();
    }
    if (status === 'completed' && !step.completedAt) {
      step.completedAt = Date.now();
    }

    todo.updatedAt = Date.now();
    await this.saveTodoDocument(projectPath, todo);
  }

  getCurrentStep(todo: TodoDocument): TodoStep | null {
    let step = todo.steps.find(s => s.status === 'in_progress');
    if (step) return step;

    step = todo.steps.find(s => s.status === 'pending');
    return step || null;
  }

  getProgress(todo: TodoDocument): { completed: number; total: number; percentage: number } {
    const completed = todo.steps.filter(s => s.status === 'completed').length;
    const total = todo.steps.length;
    const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
    return { completed, total, percentage };
  }

  // -----------------------------------------------------------
  // Parsing & Generation
  // -----------------------------------------------------------

  private parseTemplateMarkdown(templateId: string, markdown: string): WorkflowTemplate {
    const frontmatterMatch = markdown.match(/^---\n([\s\S]*?)\n---/);
    let title = templateId;
    let domain = 'General';
    let complexity: 'Simple' | 'Medium' | 'Complex' = 'Medium';
    let estimatedTime = 'Varies';
    let tools: string[] = [];

    if (frontmatterMatch) {
      const frontmatter = frontmatterMatch[1];
      const titleMatch = frontmatter.match(/title:\s*(.+)/);
      const domainMatch = frontmatter.match(/domain:\s*(.+)/);
      const complexityMatch = frontmatter.match(/complexity:\s*(.+)/);
      const timeMatch = frontmatter.match(/estimatedTime:\s*(.+)/);
      const toolsMatch = frontmatter.match(/tools:\s*\[(.*?)\]/);

      if (titleMatch) title = titleMatch[1].trim();
      if (domainMatch) domain = domainMatch[1].trim();
      if (complexityMatch) complexity = complexityMatch[1].trim() as any;
      if (timeMatch) estimatedTime = timeMatch[1].trim();
      if (toolsMatch) tools = toolsMatch[1].split(',').map(t => t.trim());
    }

    const contentAfterFrontmatter = markdown.replace(/^---\n[\s\S]*?\n---\n/, '');
    const descMatch = contentAfterFrontmatter.match(/^#[^\n]*\n\n([^\n]+)/);
    const description = descMatch ? descMatch[1].trim() : 'No description';

    const steps = this.extractStepsFromMarkdown(contentAfterFrontmatter);

    return {
      id: templateId,
      title,
      domain,
      complexity,
      estimatedTime,
      description,
      tools,
      steps,
    };
  }

  private extractStepsFromMarkdown(markdown: string): import('../types').WorkflowStep[] {
    const steps: import('../types').WorkflowStep[] = [];
    const stepRegex = /## Step (\d+):\s*([^\n]+)\n([\s\S]*?)(?=\n## Step \d+:|$)/g;
    let match;

    while ((match = stepRegex.exec(markdown)) !== null) {
      const number = parseInt(match[1], 10);
      const title = match[2].trim();
      const content = match[3].trim();

      const descMatch = content.match(/^([^\n]+)/);
      const description = descMatch ? descMatch[1].trim() : title;

      const outputsMatch = content.match(/\*\*Expected Outputs?\*\*:\s*([^\n]+)/);
      const outputs = outputsMatch
        ? outputsMatch[1].split(',').map(o => o.trim())
        : [];

      const checkpoint = content.toLowerCase().includes('checkpoint');

      steps.push({
        number,
        title,
        description,
        tools: [],
        outputs,
        checkpoint,
        estimatedTurns: 3,
      });
    }

    return steps;
  }

  private generateTodoMarkdown(todo: TodoDocument): string {
    const lines: string[] = [];

    lines.push(`# ${todo.objective}`);
    lines.push('');
    lines.push(`**Project ID**: \`${todo.projectId}\``);
    if (todo.workflowId) lines.push(`**Workflow**: ${todo.workflowId}`);
    lines.push(`**Created**: ${new Date(todo.createdAt).toISOString()}`);
    lines.push(`**Updated**: ${new Date(todo.updatedAt).toISOString()}`);
    lines.push('');

    const progress = this.getProgress(todo);
    lines.push('## Progress');
    lines.push('');
    lines.push(`- âœ… Completed: ${progress.completed}/${progress.total}`);
    lines.push(`- ðŸ“Š Overall: ${progress.percentage}%`);
    lines.push('');

    lines.push('## Steps');
    lines.push('');

    for (const step of todo.steps) {
      const enhancedStep = step as EnhancedTodoStep;
      const icon = step.status === 'completed' ? 'âœ…'
                 : step.status === 'in_progress' ? 'ðŸ”„'
                 : step.status === 'skipped' ? 'â­ï¸'
                 : 'â¸ï¸';

      const checkpoint = step.checkpoint ? ' ðŸš¦ **CHECKPOINT**' : '';
      const agent = enhancedStep.agentId ? ` ðŸ¤– Agent: \`${enhancedStep.agentId}\`` : '';

      lines.push(`### ${icon} Step ${step.number}: ${step.title}${checkpoint}${agent}`);
      lines.push('');
      lines.push(step.description);
      lines.push('');
      lines.push(`**Status**: ${step.status}`);
      lines.push('');

      if (step.outputs.length > 0) {
        lines.push(`**Expected Outputs**: ${step.outputs.join(', ')}`);
        lines.push('');
      }

      if (step.notes) {
        lines.push(`**Notes**: ${step.notes}`);
        lines.push('');
      }
    }

    return lines.join('\n');
  }

  private parseTodoMarkdown(markdown: string): TodoDocument | null {
    try {
      const titleMatch = markdown.match(/^# (.+)/m);
      const objective = titleMatch ? titleMatch[1].trim() : 'Unknown Objective';

      const projectIdMatch = markdown.match(/\*\*Project ID\*\*:\s*`([^`]+)`/);
      const projectId = projectIdMatch ? projectIdMatch[1].trim() : '';

      const workflowIdMatch = markdown.match(/\*\*Workflow\*\*:\s*(.+)/);
      const workflowId = workflowIdMatch ? workflowIdMatch[1].trim() : undefined;

      const createdMatch = markdown.match(/\*\*Created\*\*:\s*(.+)/);
      const updatedMatch = markdown.match(/\*\*Updated\*\*:\s*(.+)/);
      const createdAt = createdMatch ? new Date(createdMatch[1].trim()).getTime() : Date.now();
      const updatedAt = updatedMatch ? new Date(updatedMatch[1].trim()).getTime() : Date.now();

      const steps: EnhancedTodoStep[] = [];
      const stepRegex = /### [^\s]+ Step (\d+):\s*([^\nðŸš¦ðŸ¤–]+)(?:ðŸš¦\s*\*\*CHECKPOINT\*\*)?(?:ðŸ¤–\s*Agent:\s*`([^`]+)`)?[\s\S]*?\n\*\*Status\*\*:\s*(\w+)/g;
      let match;

      while ((match = stepRegex.exec(markdown)) !== null) {
        const number = parseInt(match[1], 10);
        const title = match[2].trim();
        const agentId = match[3]?.trim();
        const status = match[4] as TodoStep['status'];

        const stepStart = match.index;
        const nextMatch = /### [^\s]+ Step \d+:/.exec(markdown.slice(stepStart + 1));
        const stepEnd = nextMatch ? stepStart + 1 + nextMatch.index : markdown.length;
        const stepContent = markdown.slice(stepStart, stepEnd);

        const descMatch = stepContent.match(/###[^\n]+\n\n([^\n]+)/);
        const description = descMatch ? descMatch[1].trim() : title;

        const outputsMatch = stepContent.match(/\*\*Expected Outputs\*\*:\s*([^\n]+)/);
        const outputs = outputsMatch
          ? outputsMatch[1].split(',').map(o => o.trim())
          : [];

        const notesMatch = stepContent.match(/\*\*Notes\*\*:\s*([^\n]+)/);
        const notes = notesMatch ? notesMatch[1].trim() : undefined;

        const checkpoint = stepContent.includes('ðŸš¦');

        steps.push({
          number,
          title,
          description,
          status,
          checkpoint,
          outputs,
          notes,
          agentId,
        });
      }

      return {
        objective,
        projectId,
        workflowId,
        createdAt,
        updatedAt,
        steps,
      };
    } catch (e) {
      console.error('[WorkflowManager] Failed to parse todo.md:', e);
      return null;
    }
  }

  private generateReadme(projectId: string, objective: string, template: WorkflowTemplate): string {
    return `# ${objective}

**Project ID**: \`${projectId}\`
**Workflow Template**: ${template.title}

## Overview
${template.description}

## Project Structure

- \`todo.md\` - Step-by-step plan with agent assignments
- \`data/\` - Raw data, research, intermediate files
- \`results/\` - Final deliverables
- \`artifacts/\` - Code, visualizations, tools

## Workflow Steps

${template.steps.map(s => `${s.number}. ${s.title}`).join('\n')}

## Progress

See \`todo.md\` for current progress and step details.

---
*Generated by ORION Multi-Agent Workflow System*
`;
  }

  // -----------------------------------------------------------
  // Agent Registry Access
  // -----------------------------------------------------------

  getAgentRegistry(): AgentRegistry {
    return this.agentRegistry;
  }
}

export default EnhancedWorkflowManager;